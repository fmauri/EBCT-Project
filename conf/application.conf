play.http.secret.key="bG85BeTZ[iNYAU;DXjEXmLos]BM9BaMlwpa8bfUTwU:G/HGHWz8JGbNZJ2Gm_TT2"
# This is the main configuration file for the application.
# https://www.playframework.com/documentation/latest/ConfigFile
db {
  default.driver = org.h2.Driver
  default.url = "jdbc:h2:mem:play1"
//  # db.default.driver=org.postgresql.Driver
  # db.default.url=${DATABASE_URL}
  #default.username = sa
  #default.password = ""
}
# ebean.default = ["models.*"]

#play.filters.enabled += "play.filters.headers.SecurityHeadersFilter"
# play.filters.headers.contentSecurityPolicy="script-src 'self' 'unsafe-inline'"
#play.filters.headers.contentSecurityPolicy=null //disables CSP.

play.filters.disabled+=play.filters.csrf.CSRFFilter // TODO Configure security filters correctly before production use.
play.filters.headers.contentSecurityPolicy=null //disables CSP.

# play.evolutions.autoApply = true
# applyEvolutions.default=true
# -Dplay.evolutions.db.default.autoApplyDowns=true

session {
  # Sets the cookie to be sent only over HTTPS.
  #secure = true

  # Sets the cookie to be accessed only by the server.
  #httpOnly = true

  # Sets the max-age field of the cookie to 5 minutes.
  # NOTE: this only sets when the browser will discard the cookie. Play will consider any
  # cookie value with a valid signature to be a valid session forever. To implement a server side session timeout,
  # you need to put a timestamp in the session and check it at regular intervals to possibly expire it.
  #maxAge = 300

  # Sets the domain on the session cookie.
  #domain = "example.com"
}

flash {
  # Sets the cookie to be sent only over HTTPS.
  #secure = true

  # Sets the cookie to be accessed only by the server.
  #httpOnly = true
}

## Netty Provider
# https://www.playframework.com/documentation/latest/SettingsNetty
# ~~~~~
play.server.netty {
  # Whether the Netty wire should be logged
  #log.wire = true

  # If you run Play on Linux, you can use Netty's native socket transport
  # for higher performance with less garbage.
  #transport = "native"
}

## WS (HTTP Client)
# https://www.playframework.com/documentation/latest/ScalaWS#Configuring-WS
# ~~~~~
# The HTTP client primarily used for REST APIs.  The default client can be
# configured directly, but you can also create different client instances
# with customized settings. You must enable this by adding to build.sbt:
#
# libraryDependencies += ws // or javaWs if using java
#
play.ws {
  # Sets HTTP requests not to follow 302 requests
  #followRedirects = false

  # Sets the maximum number of open HTTP connections for the client.
  #ahc.maxConnectionsTotal = 50

  ## WS SSL
  # https://www.playframework.com/documentation/latest/WsSSL
  # ~~~~~
  ssl {
    # Configuring HTTPS with Play WS does not require programming.  You can
    # set up both trustManager and keyManager for mutual authentication, and
    # turn on JSSE debugging in development with a reload.
    #debug.handshake = true
    #trustManager = {
    #  stores = [
    #    { type = "JKS", path = "exampletrust.jks" }
    #  ]
    #}
  }
}

## Cache
# https://www.playframework.com/documentation/latest/JavaCache
# https://www.playframework.com/documentation/latest/ScalaCache
# ~~~~~
# Play comes with an integrated cache API that can reduce the operational
# overhead of repeated requests. You must enable this by adding to build.sbt:
#
# libraryDependencies += cache
#
play.cache {
  # If you want to bind several caches, you can bind the individually
  #bindCaches = ["db-cache", "user-cache", "session-cache"]
}

## Filter Configuration
# https://www.playframework.com/documentation/latest/Filters
# ~~~~~
# There are a number of built-in filters that can be enabled and configured
# to give Play greater security.
#
play.filters {
  hosts {
    # Allow requests to example.com, its subdomains, and localhost:9000.
    allowed = [".herokuapp.com", "localhost:9000"]
  }
}